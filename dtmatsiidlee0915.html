<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>DataMatrix 검증기</title>
<style>
  body{font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", Arial; margin:0; padding:0; background:#f2f6fb; color:#222}
  header{background:#1565c0;color:#fff;padding:12px 14px;font-size:18px;font-weight:600}
  .container{padding:12px}
  .video-wrap{background:#000;border-radius:8px;overflow:hidden;max-width:720px;position:relative;min-height:300px}
  video{width:100%;height:auto;display:block}
  .controls{margin-top:10px; display:flex; gap:8px; flex-wrap:wrap}
  button{background:#0b79d0;color:#fff;border:none;padding:10px 12px;border-radius:8px;font-weight:600;cursor:pointer}
  button:disabled{background:#ccc;cursor:not-allowed}
  button.secondary{background:#ddd;color:#333}
  .result{margin-top:14px;background:#fff;padding:10px;border-radius:8px;box-shadow:0 1px 4px rgba(0,0,0,.08)}
  pre.raw{white-space:pre-wrap;background:#111;color:#bde; padding:10px;border-radius:6px;overflow:auto}
  table{width:100%;border-collapse:collapse;margin-top:8px}
  th,td{padding:8px;border:1px solid #e6eef8;text-align:left}
  th{background:#f4f9ff}
  .ok{color:#0b7b0b;font-weight:700}
  .ng{color:#c62828;font-weight:700}
  .hint{font-size:13px;color:#666;margin-top:8px}
  input[type=file]{display:inline-block}
  .small{font-size:13px;color:#444}
  .scan-overlay{position:absolute;top:0;left:0;right:0;bottom:0;display:flex;justify-content:center;align-items:center;pointer-events:none}
  .scan-frame{width:70%;height:70%;border:2px solid #00ff00;border-radius:8px;box-shadow:0 0 0 1000px rgba(0,0,0,0.5)}
  .status{text-align:center;color:#fff;margin-top:10px;font-weight:bold}
  
  /* 탭 스타일 */
  .tabs-container {margin-top: 16px;}
  .tabs-header {display: flex; border-bottom: 1px solid #e0e0e0; overflow-x: auto;}
  .tab-button {padding: 10px 16px; background: none; border: none; cursor: pointer; border-bottom: 2px solid transparent; white-space: nowrap;}
  .tab-button.active {border-bottom-color: #1565c0; color: #1565c0; font-weight: 600;}
  .tab-content {display: none; padding: 16px 0;}
  .tab-content.active {display: block;}
  .token-info {margin-bottom: 12px;}
  .token-field {margin-bottom: 8px; display: flex;}
  .token-label {font-weight: 600; min-width: 120px;}
  .token-value {flex: 1; word-break: break-all;}
</style>
<script src="https://cdn.jsdelivr.net/npm/@zxing/library@latest/umd/index.min.js"></script>
</head>
<body>
<header>DataMatrix 검증기 (iPhone 호환)</header>
<div class="container">
  <div class="video-wrap" id="videoWrap">
    <video id="video" playsinline></video>
    <div class="scan-overlay">
      <div class="scan-frame"></div>
      <div class="status" id="status">카메라 시작 버튼을 누르세요</div>
    </div>
  </div>

  <div class="controls">
    <button id="startBtn">카메라 시작</button>
    <button id="stopBtn" class="secondary" disabled>카메라 중지</button>
    <label class="secondary small" style="padding:8px;border-radius:8px;cursor:pointer">
      이미지 업로드
      <input id="fileInput" type="file" accept="image/*" style="display:none" />
    </label>
    <button id="clearBtn" class="secondary">초기화</button>
  </div>

  <div class="result" id="resultBox">
    <div><strong>디코드 원문:</strong></div>
    <pre class="raw" id="rawText">(스캔 또는 업로드 후 결과가 여기에 표시됩니다)</pre>

    <div class="hint">참고: ANSI / ISO 15434 스타일의 구분자( RS=ASCII30, GS=ASCII29, EOT=ASCII4 )와 일반문자 '#', 'EOT' 등 여러 표현을 허용하여 인식합니다.</div>

    <!-- 요약 테이블 -->
    <table id="tableParsed">
      <thead><tr><th>항목</th><th>결과</th><th>값</th></tr></thead>
      <tbody>
        <tr><td>Header</td><td id="hdrRes"></td><td id="hdrVal"></td></tr>
        <tr><td>업체코드</td><td id="vendorRes"></td><td id="vendorVal"></td></tr>
        <tr><td>부품번호</td><td id="partRes"></td><td id="partVal"></td></tr>
        <tr><td>서열/서브코드</td><td id="seqRes"></td><td id="seqVal"></td></tr>
        <tr><td>생산일자 (yymmdd)</td><td id="dateRes"></td><td id="dateVal"></td></tr>
        <tr><td>부품4M</td><td id="m4Res"></td><td id="m4Val"></td></tr>
        <tr><td>A or @</td><td id="aRes"></td><td id="aVal"></td></tr>
        <tr><td>추적번호 (7자리 이상)</td><td id="traceRes"></td><td id="traceVal"></td></tr>
        <tr><td>초도품구분</td><td id="firstRes"></td><td id="firstVal"></td></tr>
        <tr><td>업체영역</td><td id="areaRes"></td><td id="areaVal"></td></tr>
        <tr><td>Trailer</td><td id="trailRes"></td><td id="trailVal"></td></tr>
      </tbody>
    </table>

    <!-- 토큰 탭 섹션 -->
    <div class="tabs-container">
      <div><strong>토큰 상세 분석:</strong></div>
      <div class="tabs-header" id="tabsHeader">
        <!-- 탭 버튼들이 동적으로 추가될 곳 -->
      </div>
      <div class="tab-contents" id="tabContents">
        <!-- 탭 내용들이 동적으로 추가될 곳 -->
      </div>
    </div>
  </div>
</div>

<script>
// UPDATED BASE CODE - 토큰 탭 기능 추가
(function(){
  const video = document.getElementById('video');
  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const fileInput = document.getElementById('fileInput');
  const rawText = document.getElementById('rawText');
  const statusEl = document.getElementById('status');
  const tabsHeader = document.getElementById('tabsHeader');
  const tabContents = document.getElementById('tabContents');
  
  const codeReader = new ZXing.BrowserMultiFormatReader();
  let isScanning = false;
  let currentDeviceId = null;

  const setCell = (id, ok, val) => {
    const el = document.getElementById(id);
    if(ok === null) { 
      el.innerHTML=''; 
      return; 
    }
    el.innerHTML = (ok ? '<span class="ok">OK</span>' : '<span class="ng">NG</span>');
    const valElId = id.replace('Res','Val');
    document.getElementById(valElId).innerText = val ?? '';
  };

  function updateStatus(message) {
    statusEl.textContent = message;
  }

  // 탭 전환 함수
  function switchTab(tabIndex) {
    // 모든 탭 버튼 비활성화
    const tabButtons = tabsHeader.querySelectorAll('.tab-button');
    tabButtons.forEach(button => button.classList.remove('active'));
    
    // 모든 탭 내용 숨기기
    const tabContentElements = tabContents.querySelectorAll('.tab-content');
    tabContentElements.forEach(content => content.classList.remove('active'));
    
    // 선택한 탭 활성화
    tabButtons[tabIndex].classList.add('active');
    tabContentElements[tabIndex].classList.add('active');
  }

  // 토큰 탭 생성 함수
  function createTokenTabs(tokens) {
    // 기존 탭 내용 초기화
    tabsHeader.innerHTML = '';
    tabContents.innerHTML = '';
    
    if (!tokens || tokens.length === 0) {
      return;
    }
    
    // 각 토큰에 대한 탭 생성
    tokens.forEach((token, index) => {
      // 탭 버튼 생성
      const tabButton = document.createElement('button');
      tabButton.className = `tab-button ${index === 0 ? 'active' : ''}`;
      tabButton.textContent = `토큰 ${index + 1}`;
      tabButton.addEventListener('click', () => switchTab(index));
      tabsHeader.appendChild(tabButton);
      
      // 탭 내용 생성
      const tabContent = document.createElement('div');
      tabContent.className = `tab-content ${index === 0 ? 'active' : ''}`;
      tabContent.id = `token-${index}`;
      
      // 토큰 정보 추가
      const tokenInfo = document.createElement('div');
      tokenInfo.className = 'token-info';
      
      // 토큰 길이
      const lengthField = document.createElement('div');
      lengthField.className = 'token-field';
      lengthField.innerHTML = `<span class="token-label">길이:</span> <span class="token-value">${token.length} 문자</span>`;
      tokenInfo.appendChild(lengthField);
      
      // 토큰 내용
      const contentField = document.createElement('div');
      contentField.className = 'token-field';
      contentField.innerHTML = `<span class="token-label">내용:</span> <span class="token-value">${escapeHtml(token)}</span>`;
      tokenInfo.appendChild(contentField);
      
      // 토큰 유형 분석
      const typeField = document.createElement('div');
      typeField.className = 'token-field';
      const tokenType = analyzeTokenType(token, index);
      typeField.innerHTML = `<span class="token-label">유형:</span> <span class="token-value">${tokenType}</span>`;
      tokenInfo.appendChild(typeField);
      
      // 토큰 검증 결과
      const validationField = document.createElement('div');
      validationField.className = 'token-field';
      const validationResult = validateToken(token, index);
      validationField.innerHTML = `<span class="token-label">검증:</span> <span class="token-value ${validationResult.isValid ? 'ok' : 'ng'}">${validationResult.message}</span>`;
      tokenInfo.appendChild(validationField);
      
      tabContent.appendChild(tokenInfo);
      tabContents.appendChild(tabContent);
    });
  }

  // 토큰 유형 분석 함수
  function analyzeTokenType(token, index) {
    if (index === 0 && token.startsWith('[)>')) {
      return '헤더 (Header)';
    }
    if (token.startsWith('V') && /^V[A-Z0-9]{2,}$/i.test(token)) {
      return '업체 코드 (Vendor Code)';
    }
    if (token.startsWith('P') && /^P[0-9A-Z]+/i.test(token)) {
      return '부품 번호 (Part Number)';
    }
    if (token.startsWith('S') && /^S[A-Z0-9]{1,6}$/i.test(token)) {
      return '서열 코드 (Sequence Code)';
    }
    if (token.startsWith('T') && /^T\d{6}/.test(token)) {
      return '추적 코드 (Trace Code)';
    }
    if (token === 'N' || token === 'Y') {
      return '초도품 구분 (First Item Flag)';
    }
    if (/^[A-Z][A-Z0-9]{2,}$/i.test(token) && token.length > 3) {
      return '업체 영역 (Company Area)';
    }
    if (token === '\x04' || token === 'EOT' || token === '#') {
      return '트레일러 (Trailer)';
    }
    
    return '일반 데이터 (General Data)';
  }

  // 토큰 검증 함수
  function validateToken(token, index) {
    if (index === 0 && !token.startsWith('[)>')) {
      return { isValid: false, message: '헤더 형식이 올바르지 않습니다' };
    }
    if (token.startsWith('V') && !/^V[A-Z0-9]{2,}$/i.test(token)) {
      return { isValid: false, message: '업체 코드 형식이 올바르지 않습니다' };
    }
    if (token.startsWith('P') && !/^P[0-9A-Z]+/i.test(token)) {
      return { isValid: false, message: '부품 번호 형식이 올바르지 않습니다' };
    }
    if (token.startsWith('S') && !/^S[A-Z0-9]{1,6}$/i.test(token)) {
      return { isValid: false, message: '서열 코드 형식이 올바르지 않습니다' };
    }
    if (token.startsWith('T') && !/^T\d{6}/.test(token)) {
      return { isValid: false, message: '추적 코드 형식이 올바르지 않습니다' };
    }
    
    return { isValid: true, message: '형식이 올바릅니다' };
  }

  // HTML 이스케이프 함수
  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  // 카메라 시작 - decodeFromVideoDevice 방식으로 변경
  startBtn.addEventListener('click', async () => {
    if (isScanning) return;
    
    try {
      updateStatus('카메라 접근 중...');
      startBtn.disabled = true;
      
      // 사용 가능한 카메라 장치 목록 가져오기
      const videoInputDevices = await codeReader.listVideoInputDevices();
      
      if (videoInputDevices.length === 0) {
        updateStatus('카메라를 찾을 수 없습니다');
        startBtn.disabled = false;
        return;
      }
      
      // 후면 카메라 우선 선택 (iPhone에서 더 나은 품질)
      let selectedDeviceId = videoInputDevices[0].deviceId;
      const backCamera = videoInputDevices.find(device => 
        device.label.toLowerCase().includes('back') || 
        device.label.toLowerCase().includes('rear') ||
        device.label.toLowerCase().includes('후면')
      );
      
      if (backCamera) {
        selectedDeviceId = backCamera.deviceId;
      }
      
      currentDeviceId = selectedDeviceId;
      
      // 비디오 요소 설정
      video.setAttribute('autoplay', '');
      video.setAttribute('muted', '');
      video.setAttribute('playsinline', '');
      
      // 지속적인 디코딩 시작
      codeReader.decodeFromVideoDevice(selectedDeviceId, video, (result, err) => {
        if (result) {
          // 성공적으로 디코딩된 경우
          updateStatus('코드 인식 성공!');
          parseAndValidate(result.text);
          
          // 잠시 후 스캔 상태로 복귀
          setTimeout(() => {
            if (isScanning) {
              updateStatus('코드를 스캔 중...');
            }
          }, 1500);
        }
        
        if (err && !(err instanceof ZXing.NotFoundException)) {
          console.error('Decode error:', err);
        }
      });
      
      updateStatus('코드를 스캔 중...');
      stopBtn.disabled = false;
      isScanning = true;
      
    } catch (error) {
      console.error('Camera error:', error);
      updateStatus('카메라 접근 실패: ' + error.message);
      startBtn.disabled = false;
    }
  });

  // 카메라 중지
  stopBtn.addEventListener('click', () => {
    stopScanning();
    updateStatus('카메라가 중지되었습니다');
  });

  function stopScanning() {
    if (isScanning) {
      codeReader.reset();
      isScanning = false;
    }
    
    if (video.srcObject) {
      video.srcObject.getTracks().forEach(track => track.stop());
      video.srcObject = null;
    }
    
    startBtn.disabled = false;
    stopBtn.disabled = true;
    currentDeviceId = null;
  }

  // 파일 업로드 처리
  fileInput.addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = async (e) => {
      updateStatus('이미지 분석 중...');
      
      try {
        const result = await codeReader.decodeFromImage(undefined, e.target.result);
        if (result) {
          parseAndValidate(result.text);
          updateStatus('이미지에서 코드 인식 성공!');
        } else {
          updateStatus('이미지에서 코드를 찾을 수 없습니다');
        }
      } catch (error) {
        updateStatus('이미지 디코딩 실패: ' + error.message);
      }
    };
    reader.readAsDataURL(file);
  });

  // 데이터 파싱 및 검증 함수들
  function normalizeControls(s){
    if(!s) return '';
    s = s.replace(/\\r\\n/g,'').replace(/\\r/g,'').replace(/\\n/g,'');
    s = s.replace(/\\[\\>\\)]/g,'[)>');
    s = s.replace(/<RS>|\\bRS\\b/gi, '\x1E');
    s = s.replace(/<GS>|\\bGS\\b/gi, '\x1D');
    s = s.replace(/<EOT>|\\bEOT\\b/gi, '\x04');
    s = s.replace(/[\u001D\u001E\u0004]/g, function(ch){ return ch; });
    return s.trim();
  }

  function splitTokens(s){
    const GS = '\x1D';
    if(s.indexOf(GS) >= 0) return s.split(GS).map(x => x.trim());
    const alt = s.split(/[\u001D\u001E#\|]/).map(x=>x.trim()).filter(Boolean);
    return alt;
  }

  function parseAndValidate(raw){
    raw = raw || '';
    const original = raw;
    raw = normalizeControls(raw);

    rawText.innerText = printableRepresentation(original);

    // 토큰 분리 및 탭 생성
    const tokens = splitTokens(raw);
    createTokenTabs(tokens);

    let header_ok = false, header_val='';
    const RS = '\x1E';
    if(raw.indexOf('[)>') >= 0 && raw.indexOf(RS+'06') >= 0) {
      header_ok = true;
      header_val = '[)>' + '\\u001E' + '06';
    } else {
      if(/^\[>\)|^\[\)\>/.test(raw) || raw.startsWith('[)>')) {
        header_ok = raw.includes('06');
        header_val = raw.slice(0, Math.min(6, raw.length));
      }
    }
    setCell('hdrRes', header_ok, header_val);

    ['vendor','part','seq','date','m4','a','trace','first','area','trail'].forEach(k=>{
      setCell(k+'Res', null, '');
    });

    let vendor = '', part = '', seq = '', date='', m4='', a_or='',
        trace='', firstFlag='', area='', trailer='';

    if(raw.indexOf('\x04')>=0 || raw.indexOf('EOT')>=0 || raw.indexOf('#')>=0) {
      trailer = 'present';
    } else trailer = 'missing';

    setCell('trailRes', !!trailer && trailer!=='missing', trailer);

    let work = raw;
    if(header_ok) {
      const idx = work.indexOf('06');
      if(idx>=0) work = work.slice(idx+2);
    }

    const parts = splitTokens(work).filter(x=>x.length>0);
    
    if(parts.length>0){
      vendor = parts[0].replace(/^[\x1D\x1E]+/,'');
      if(/^V[A-Z0-9]{3,4}$/i.test(vendor) && vendor.length>3) vendor = vendor.slice(1);
    }

    for(let t of parts){
      if(/^P[0-9A-Z]+/i.test(t)){
        part = t.replace(/^P/,'P');
        break;
      }
    }

    for(let t of parts){
      if(/^S[A-Z0-9]{1,6}/i.test(t) && !/^P/.test(t)){
        seq = t;
        break;
      }
    }

    for(let t of parts){
      if(/^T\d{6}[A-Z0-9@]{4,}/i.test(t) || /^T/.test(t)){
        trace = t;
        break;
      }
    }

    if(trace){
      const m = trace.match(/^T(\d{6})([A-Z0-9]{2,5})([A@])([A-Z0-9]+)$/i);
      if(m){
        date = m[1];
        m4 = m[2];
        a_or = m[3];
        trace = m[4];
      } else {
        const m2 = trace.match(/^T(\d{6})(.+)$/i);
        if(m2){
          date = m2[1];
          const rest = m2[2];
          const mm = rest.match(/^([A-Z0-9]{3,5})([A@])([A-Z0-9]+)$/i);
          if(mm){ m4 = mm[1]; a_or = mm[2]; trace = mm[3]; }
          else {
            const mm2 = rest.match(/^([A-Z0-9]{3,6})([0-9]{6,})$/i);
            if(mm2){ m4 = mm2[1]; trace = mm2[2]; }
            else {
              trace = rest;
            }
          }
        }
      }
    }

    for(let t of parts){
      if(/^[NY]$/i.test(t) && t.length===1) { firstFlag = t; break; }
    }

    for(let i=parts.length-1;i>=0;i--){
      const t=parts[i];
      if(/^[A-Z][A-Z0-9]{2,}$/i.test(t) && t.length>3){
        area = t;
        break;
      }
    }

    const vendor_ok = /^[A-Z0-9]{3,5}$/i.test(vendor);
    setCell('vendorRes', vendor_ok, vendor);

    const part_ok = /^P?[0-9A-Z]{4,}$/i.test(part) || /P\d{3,}/i.test(part);
    setCell('partRes', part_ok, part);

    const seq_ok = /^S[A-Z0-9]{1,6}$/i.test(seq);
    setCell('seqRes', seq_ok, seq);

    let date_ok=false;
    if(/^\d{6}$/.test(date)){
      const yy = parseInt(date.slice(0,2),10);
      const mm = parseInt(date.slice(2,4),10);
      const dd = parseInt(date.slice(4,6),10);
      if(mm>=1 && mm<=12 && dd>=1 && dd<=31) date_ok = true;
    }
    setCell('dateRes', date_ok, date);

    const m4_ok = /^[A-Z0-9]{3,5}$/i.test(m4);
    setCell('m4Res', m4_ok, m4);

    const a_ok = /^[A@]$/.test(a_or);
    setCell('aRes', a_ok, a_or);

    const trace_ok = trace && trace.length>=7;
    setCell('traceRes', trace_ok, trace);

    const first_ok = firstFlag ? /^[NY]$/i.test(firstFlag) : true;
    setCell('firstRes', first_ok, firstFlag);

    const area_ok = area ? /^[A-Z][A-Z0-9]{2,}$/i.test(area) : false;
    setCell('areaRes', area_ok, area);

    const trailer_ok = (raw.indexOf('\x04')>=0) || /EOT|#/.test(raw);
    setCell('trailRes', trailer_ok, trailer_ok ? 'present' : 'missing');

    return {
      header_ok, vendor, vendor_ok, part, part_ok, seq, seq_ok,
      date, date_ok, m4, m4_ok, a_or, a_ok, trace, trace_ok,
      firstFlag, first_ok, area, area_ok, trailer_ok
    };
  }

  function printableRepresentation(s){
    if(!s) return '';
    return s.replace(/\x1E/g,'<RS>').replace(/\x1D/g,'<GS>').replace(/\x04/g,'<EOT>');
  }

  // 초기화 버튼
  document.getElementById('clearBtn').addEventListener('click', ()=>{
    rawText.innerText = '(스캔 또는 업로드 후 결과가 여기에 표시됩니다)';
    tabsHeader.innerHTML = '';
    tabContents.innerHTML = '';
    ['hdr','vendor','part','seq','date','m4','a','trace','first','area','trail'].forEach(k=>{
      const rid = k+'Res'; document.getElementById(rid).innerHTML='';
      const vid = k+'Val'; if(document.getElementById(vid)) document.getElementById(vid).innerText='';
    });
    updateStatus('카메라 시작 버튼을 누르세요');
  });

  window._parseAndValidate = parseAndValidate;

})();
</script>
</body>
</html>
